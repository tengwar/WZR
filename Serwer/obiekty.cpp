/*********************************************************************
    Symulacja obiektów fizycznych ruchomych np. samochody, statki, roboty, itd. 
    + obs³uga obiektów statycznych np. teren.
**********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#include <gl\gl.h>
#include <gl\glu.h>
#include "obiekty.h"
#include "grafika.h"

//#include "wektor.h"
extern FILE *f;
extern Teren teren;
extern int iLiczbaInnychOb;
extern ObiektRuchomy *InneObiekty[2000]; 


ObiektRuchomy::ObiektRuchomy()             // konstruktor                   
{

	//iID = (unsigned int)(clock() % 1000);  // identyfikator obiektu
	iID = (unsigned int)(rand() % 1000);  // identyfikator obiektu
    fprintf(f,"MojObiekt->iID = %d\n",iID);


	F = Fb = alfa  = 0;	// si³y dzia³aj¹ce na obiekt 
	ham = 0;			// stopieñ hamowania
	m = 1.0;			// masa obiektu
	Fy = m*9.81;        // si³a nacisku na podstawê obiektu (na ko³a pojazdu)
	dlugosc = 7.1;
	szerokosc = 2.3;
	wysokosc = 1.3;
	przeswit = 0.0;     // wysokoœæ na której znajduje siê podstawa obiektu
	dl_przod = 1.3;     // odleg³oœæ od przedniej osi do przedniego zderzaka 
	dl_tyl = 0.2;       // odleg³oœæ od tylniej osi do tylniego zderzaka
	
  wPol.y = przeswit+wysokosc/2 + 20;
  wPol.x = -50;
  //wV_kat = Wektor3(0,1,0)*40;  // pocz¹tkowa prêdkoœæ k¹towa (w celach testowych)

	// obrót obiektu o k¹t 30 stopni wzglêdem osi y:
	kwaternion qObr = AsixToQuat(Wektor3(0,1,0),0.1*PI/180.0);
	qOrient = qObr*qOrient;
}

ObiektRuchomy::~ObiektRuchomy()            // destruktor
{
}

void ObiektRuchomy::ZmienStan(StanObiektu stan)  // przepisanie podanego stanu 
{                                                // w przypadku obiektów, które nie s¹ symulowane
	this->iID = stan.iID;                        

	this->wPol = stan.wPol;
	this->qOrient = stan.qOrient;
	this->wV = stan.wV;
	this->wA = stan.wA;
	this->wV_kat = stan.wV_kat;
	this->wA_kat = stan.wA_kat;
}

StanObiektu ObiektRuchomy::Stan()                // metoda zwracaj¹ca stan obiektu ³¹cznie z iID
{
	StanObiektu stan;

	stan.iID = iID;
	stan.qOrient = qOrient;
	stan.wA = wA;
	stan.wA_kat = wA_kat;
	stan.wPol = wPol;
	stan.wV = wV;
	stan.wV_kat = wV_kat;
	return stan;
}

void ObiektRuchomy::Symulacja(float dt)          // obliczenie nowego stanu na podstawie dotychczasowego,
{                                                // dzia³aj¹cych si³ i czasu, jaki up³yn¹³ od ostatniej symulacji

  if (dt == 0) return;

  float tarcie = 2.5;            // wspó³czynnik tarcia obiektu o pod³o¿e 
  float tarcie_obr = tarcie;     // tarcie obrotowe (w szczególnych przypadkach mo¿e byæ inne ni¿ liniowe)
  float tarcie_toczne = 0.05;    // wspó³czynnik tarcia tocznego 
  float g = 9.81;                // przyspieszenie grawitacyjne

  // obliczam wektor skierowany do przodu obiektu, by przesun¹æ obiekt w kierunku tego wektora 
  // proporcjonalnie do si³y F:
  Wektor3 w_przod = Wektor3(1,0,0);		// na razie oœ obiektu pokrywa siê z osi¹ x globalnego uk³adu wspó³rzêdnych (lokalna oœ x)
  Wektor3 w_gora = Wektor3(0,1,0);		// wektor skierowany pionowo w górê od podstawy obiektu (lokalna oœ y)
  Wektor3 w_prawo = Wektor3(0,0,1);       // wektor skierowany w prawo (lokalna oœ z)

  // obracam uk³ad wspó³rzêdnych lokalnych wed³ug kwaterniona orientacji:
  w_przod = qOrient.obroc_wektor(w_przod);
  w_gora = qOrient.obroc_wektor(w_gora);
  w_prawo = qOrient.obroc_wektor(w_prawo);

  fprintf(f,"w_przod = (%f, %f, %f)\n",w_przod.x,w_przod.y,w_przod.z);
  fprintf(f,"w_gora = (%f, %f, %f)\n",w_gora.x,w_gora.y,w_gora.z);
  fprintf(f,"w_prawo = (%f, %f, %f)\n",w_prawo.x,w_prawo.y,w_prawo.z);

  fprintf(f,"|w_przod|=%f,|w_gora|=%f,|w_prawo|=%f\n",w_przod.dlugosc(),w_gora.dlugosc(),w_prawo.dlugosc()  );
  fprintf(f,"ilo skalar = %f,%f,%f\n",w_przod^w_prawo,w_przod^w_gora,w_gora^w_prawo  );
  //fprintf(f,"w_przod = (%f, %f, %f) w_gora = (%f, %f, %f) w_prawo = (%f, %f, %f)\n",
  //           w_przod.x,w_przod.y,w_przod.z,w_gora.x,w_gora.y,w_gora.z,w_prawo.x,w_prawo.y,w_prawo.z);


  // rzutujemy wV na sk³adow¹ w kierunku przodu i pozosta³e 2 sk³adowe
  // sk³adowa w bok jest zmniejszana przez si³ê tarcia, sk³adowa do przodu
  // przez si³ê tarcia tocznego
  Wektor3 wV_wprzod = w_przod*(wV^w_przod),
    wV_wprawo = w_prawo*(wV^w_prawo),
    wV_wgore = w_gora*(wV^w_gora); 

  // rzutujemy prêdkoœæ k¹tow¹ wV_kat na sk³adow¹ w kierunku przodu i pozosta³e 2 sk³adowe
  Wektor3 wV_kat_wprzod = w_przod*(wV_kat^w_przod),
    wV_kat_wprawo = w_prawo*(wV_kat^w_prawo),
    wV_kat_wgore = w_gora*(wV_kat^w_gora);         

  // obliczam promien skrêtu pojazdu na podstawie k¹ta skrêtu kó³, a nastêpnie na podstawie promienia skrêtu
  // obliczam prêdkoœæ k¹tow¹ (UPROSZCZENIE! pomijam przyspieszenie k¹towe oraz w³aœciw¹ trajektoriê ruchu)
  if (Fy > 0)
  {
    float V_kat_skret = 0;
    if (alfa != 0)
    {   
      float Rs = sqrt(dlugosc*dlugosc/4 + (fabs(dlugosc/tan(alfa)) + szerokosc/2)*(fabs(dlugosc/tan(alfa)) + szerokosc/2));
      V_kat_skret = wV_wprzod.dlugosc()*(1.0/Rs);
    }	
    Wektor3 wV_kat_skret = w_gora*V_kat_skret*(alfa > 0 ? 1 : -1);
    Wektor3 wV_kat_wgore2 = wV_kat_wgore + wV_kat_skret;
    if (wV_kat_wgore2.dlugosc() <= wV_kat_wgore.dlugosc()) // skrêt przeciwdzia³a obrotowi
    {
      if (wV_kat_wgore2.dlugosc() > V_kat_skret)
        wV_kat_wgore = wV_kat_wgore2; 
      else  
        wV_kat_wgore = wV_kat_skret;
    }    
    else    
    {
      if (wV_kat_wgore.dlugosc() < V_kat_skret)
        wV_kat_wgore = wV_kat_skret;

    }

    // tarcie zmniejsza prêdkoœæ obrotow¹ (UPROSZCZENIE! zamiast masy winienem wykorzystaæ moment bezw³adnoœci)     
    float V_kat_tarcie = Fy*tarcie_obr*dt/m/1.0;      // zmiana pr. k¹towej spowodowana tarciem
    float V_kat_wgore = wV_kat_wgore.dlugosc() - V_kat_tarcie;
    if (V_kat_wgore < V_kat_skret) V_kat_wgore = V_kat_skret;        // tarcie nie mo¿e spowodowaæ zmiany zwrotu wektora pr. k¹towej
    wV_kat_wgore = wV_kat_wgore.znorm()*V_kat_wgore;                     
  }    


  Fy = m*g*w_gora.y;                      // si³a docisku do pod³o¿a 
  if (Fy < 0 ) Fy = 0;
  // ... trzeba j¹ jeszcze uzale¿niæ od tego, czy obiekt styka siê z pod³o¿em!
  float Fh = Fy*tarcie*ham;                  // si³a hamowania (UP: bez uwzglêdnienia poœlizgu)

  float V_wprzod = wV_wprzod.dlugosc();// - dt*Fh/m - dt*tarcie_toczne*Fy/m;
  if (V_wprzod < 0) V_wprzod = 0;

  float V_wprawo = wV_wprawo.dlugosc();// - dt*tarcie*Fy/m;
  if (V_wprawo < 0) V_wprawo = 0;


  // wjazd lub zjazd: 
  //wPol.y = teren.Wysokosc(wPol.x,wPol.z);   // najprostsze rozwi¹zanie - obiekt zmienia wysokoœæ bez zmiany orientacji

  // 1. gdy wjazd na wklês³oœæ: wyznaczam wysokoœci terenu pod naro¿nikami obiektu (ko³ami), 
  // sprawdzam która trójka
  // naro¿ników odpowiada najni¿ej po³o¿onemu œrodkowi ciê¿koœci, gdy przylega do terenu
  // wyznaczam prêdkoœæ podbicia (wznoszenia œrodka pojazdu spowodowanego wklês³oœci¹) 
  // oraz prêdkoœæ k¹tow¹
  // 2. gdy wjazd na wypuk³oœæ to si³a ciê¿koœci wywo³uje obrót przy du¿ej prêdkoœci liniowej

  // punkty zaczepienia kó³ (na wysokoœci pod³ogi pojazdu):
  Wektor3 P = wPol + w_przod*(dlugosc/2-dl_przod) - w_prawo*szerokosc/2 - w_gora*wysokosc/2,
    Q = wPol + w_przod*(dlugosc/2-dl_przod) + w_prawo*szerokosc/2 - w_gora*wysokosc/2,
    R = wPol + w_przod*(-dlugosc/2+dl_tyl) - w_prawo*szerokosc/2 - w_gora*wysokosc/2,
    S = wPol + w_przod*(-dlugosc/2+dl_tyl) + w_prawo*szerokosc/2 - w_gora*wysokosc/2;

  // pionowe rzuty punktów zacz. kó³ pojazdu na powierzchniê terenu:  
  Wektor3 Pt = P, Qt = Q, Rt = R, St = S;
  Pt.y = teren.Wysokosc(P.x,P.z); Qt.y = teren.Wysokosc(Q.x,Q.z);  
  Rt.y = teren.Wysokosc(R.x,R.z); St.y = teren.Wysokosc(S.x,S.z);   
  Wektor3 normPQR = normalna(Pt,Rt,Qt), normPRS = normalna(Pt,Rt,St), normPQS = normalna(Pt,St,Qt),
    normQRS = normalna(Qt,Rt,St);   // normalne do p³aszczyzn wyznaczonych przez trójk¹ty

  fprintf(f,"P.y = %f, Pt.y = %f, Q.y = %f, Qt.y = %f, R.y = %f, Rt.y = %f, S.y = %f, St.y = %f\n",
    P.y, Pt.y, Q.y, Qt.y, R.y,Rt.y, S.y, St.y);

  float sryPQR = ((Qt^normPQR) - normPQR.x*wPol.x - normPQR.z*wPol.z)/normPQR.y, // wys. œrodka pojazdu
    sryPRS = ((Pt^normPRS) - normPRS.x*wPol.x - normPRS.z*wPol.z)/normPRS.y, // po najechaniu na skarpê 
    sryPQS = ((Pt^normPQS) - normPQS.x*wPol.x - normPQS.z*wPol.z)/normPQS.y, // dla 4 trójek kó³
    sryQRS = ((Qt^normQRS) - normQRS.x*wPol.x - normQRS.z*wPol.z)/normQRS.y;
  float sry = sryPQR; Wektor3 norm = normPQR;
  if (sry > sryPRS) {sry = sryPRS; norm = normPRS;}  
  if (sry > sryPQS) {sry = sryPQS; norm = normPQS;}
  if (sry > sryQRS) {sry = sryQRS; norm = normQRS;}  // wybór trójk¹ta o œrodku najni¿ej po³o¿onym    


  Wektor3 wV_kat_wpoziomie = Wektor3(0,0,0);
  // jesli któreœ z kó³ jest poni¿ej powierzchni terenu
  if ((P.y <= Pt.y + wysokosc/2+przeswit)||(Q.y <= Qt.y  + wysokosc/2+przeswit)||
    (R.y <= Rt.y  + wysokosc/2+przeswit)||(S.y <= St.y  + wysokosc/2+przeswit))
  {   
    // obliczam powsta³¹ prêdkoœæ k¹tow¹ w lokalnym uk³adzie wspó³rzêdnych:      
    Wektor3 wobrot = -norm.znorm()*w_gora;  
    wV_kat_wpoziomie = wobrot/dt; 
  }    

  // jesli wiecej niz 2 kola sa na ziemi, to przyspieszenie grawitacyjne jest rownowazone przez opor gruntu:
  if ((P.y <= Pt.y + wysokosc/2+przeswit)+(Q.y <= Qt.y  + wysokosc/2+przeswit)+
    (R.y <= Rt.y  + wysokosc/2+przeswit)+(S.y <= St.y  + wysokosc/2+przeswit) > 2)
  {	
    g = 0; 
  }
  else   // w przeciwnym wypadku brak sily docisku 
    Fy = 0;


  // sk³adam z powrotem wektor prêdkoœci k¹towej: 
  //wV_kat = wV_kat_wgore + wV_kat_wprawo + wV_kat_wprzod;  
  wV_kat = wV_kat_wgore + wV_kat_wpoziomie;


  float h = sry+wysokosc/2+przeswit - wPol.y;  // ró¿nica wysokoœci jak¹ trzeba pokonaæ  
  float V_podbicia = 0;
  if ((h > 0)&&(wV.y <= 0.01))
    V_podbicia = 0.5*sqrt(2*g*h);  // prêdkoœæ spowodowana podbiciem pojazdu przy wje¿d¿aniu na skarpê 
  if (h > 0) wPol.y = sry+wysokosc/2+przeswit;  

  // lub  w przypadku zag³êbienia siê 
  //fprintf(f,"sry = %f, wPol.y = %f, dt = %f\n",sry,wPol.y,dt);  
  //fprintf(f,"normPQR.y = %f, normPRS.y = %f, normPQS.y = %f, normQRS.y = %f\n",normPQR.y,normPRS.y,normPQS.y,normQRS.y); 

  Wektor3 dwPol = wV*dt;//wA*dt*dt/2; // czynnik bardzo ma³y - im wiêksza czêstotliwoœæ symulacji, tym mniejsze znaczenie 
  wPol = wPol + dwPol;  

  // Sprawdzenie czy obiekt mo¿e siê przemieœciæ w zadane miejsce: Jeœli nie, to 
  // przemieszczam obiekt do miejsca zetkniêcia, wyznaczam nowe wektory prêdkoœci
  // i prêdkoœci k¹towej, a nastêpne obliczam nowe po³o¿enie na podstawie nowych
  // prêdkoœci i pozosta³ego czasu. Wszystko powtarzam w pêtli (pojazd znowu mo¿e 
  // wjechaæ na przeszkodê). Problem z zaokr¹glonymi przeszkodami - konieczne 
  // wyznaczenie minimalnego kroku.


  Wektor3 wV_pop = wV;  

  // sk³adam prêdkoœci w ró¿nych kierunkach oraz efekt przyspieszenia w jeden wektor:    (problem z przyspieszeniem od si³y tarcia -> to przyspieszenie 
  //      mo¿e dzia³aæ krócej ni¿ dt -> trzeba to jakoœ uwzglêdniæ, inaczej poazd bêdzie wê¿ykowa³)
  wV = wV_wprzod.znorm()*V_wprzod + wV_wprawo.znorm()*V_wprawo + wV_wgore + 
    Wektor3(0,1,0)*V_podbicia + wA*dt;
  // usuwam te sk³adowe wektora prêdkoœci w których kierunku jazda nie jest mo¿liwa z powodu
  // przeskód:
  // np. jeœli pojazd styka siê 3 ko³ami z nawierzchni¹ lub dwoma ko³ami i œrodkiem ciê¿koœci to
  // nie mo¿e mieæ prêdkoœci w dó³ pod³ogi
  if ((P.y <= Pt.y  + wysokosc/2+przeswit)||(Q.y <= Qt.y  + wysokosc/2+przeswit)||  
    (R.y <= Rt.y  + wysokosc/2+przeswit)||(S.y <= St.y  + wysokosc/2+przeswit))    // jeœli pojazd styka siê co najm. jednym ko³em
  {
    Wektor3 dwV = wV_wgore + w_gora*(wA^w_gora)*dt;
    if ((w_gora.znorm() - dwV.znorm()).dlugosc() > 1 )  // jeœli wektor skierowany w dó³ pod³ogi
      wV = wV - dwV;
  }

  /*fprintf(f," |wV_wprzod| %f -> %f, |wV_wprawo| %f -> %f, |wV_wgore| %f -> %f |wV| %f -> %f\n",
  wV_wprzod.dlugosc(), (wV_wprzod.znorm()*V_wprzod).dlugosc(), 
  wV_wprawo.dlugosc(), (wV_wprawo.znorm()*V_wprawo).dlugosc(),
  wV_wgore.dlugosc(), (wV_wgore.znorm()*wV_wgore.dlugosc()).dlugosc(),
  wV_pop.dlugosc(), wV.dlugosc()); */

  // sk³adam przyspieszenia liniowe od si³ napêdzaj¹cych i od si³ oporu: 
  wA = (w_przod*F + w_prawo*Fb)/m*(Fy>0) - wV_wprzod.znorm()*(Fh/m + tarcie_toczne*Fy/m)*(V_wprzod>0.01)
    - wV_wprawo.znorm()*tarcie*Fy/m*(V_wprawo>0.01)- Wektor3(0,1,0)*g;

  // obliczenie nowej orientacji:
  Wektor3 w_obrot = wV_kat*dt;// + wA_kat*dt*dt/2;    
  kwaternion q_obrot = AsixToQuat(w_obrot.znorm(),w_obrot.dlugosc());
  //fprintf(f,"w_obrot = (x=%f, y=%f, z=%f) \n",w_obrot.x, w_obrot.y, w_obrot.z );
  //fprintf(f,"q_obrot = (w=%f, x=%f, y=%f, z=%f) \n",q_obrot.w, q_obrot.x, q_obrot.y, q_obrot.z );
  qOrient = q_obrot*qOrient; 	
  fprintf(f,"Pol = (%f, %f, %f) V = (%f, %f, %f) A = (%f, %f, %f) V_kat = (%f, %f, %f)\n",
    wPol.x,wPol.y,wPol.z,wV.x,wV.y,wV.z,wA.x,wA.y,wA.z,wV_kat.x,wV_kat.y,wV_kat.z);

}

void ObiektRuchomy::Rysuj()
{
  glPushMatrix();

  glTranslatef(wPol.x,wPol.y+przeswit,wPol.z);

  Wektor3 k = qOrient.AsixAngle();

  glRotatef(k.dlugosc()*180.0/PI,k.x,k.y,k.z);
  glTranslatef(-dlugosc/2,-wysokosc/2,-szerokosc/2);
  glScalef(dlugosc,wysokosc,szerokosc);

  glCallList(Auto);
  GLfloat Surface[] = { 2.0f, 2.0f, 1.0f, 1.0f};
  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, Surface);
  glRasterPos2f(0.30,1.20);
  glPrint("%d",iID ); 
  glPopMatrix();
}



//**********************
//   Obiekty nieruchome
//**********************
Teren::Teren()
{
  rozmiar_pola = 24;         // d³ugoœæ boku kwadratu w [m] 
  float t[][29] = { {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0}, // ostatni element nieu¿ywany
					          {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
					          {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
					          {0,  0,  0,  0, 10,  0,  0,  0,  0,  0,  0,  2,  5,  5,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0, 10, 10,  0,  0,  0,  0,  1,  3,  6,  9, 12, 12,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
					          {0,  0,  0,  0, 10, 10,  0,  0,  0,  0,  0,  0,  0,  0, 14,  9,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
					          {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
					          {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
					          {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
					            {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0, -2, -2, -2, -2,  0,  0,  0,  0,  0,  0,  0, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0, -6, -5, -5, -3, -3,  0,  0,  0,  0,  0,  0, -2, -2, -1,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0, -7, -6, -3, -3, -5, -4,  0,  0,  0,  0,  0, -1, -3, -3, -2,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0, -8, -8,  0,  0,  0, -4, -2,  0,  0,  0,  0,  0, -2, -3, -3,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0, -8,  0,  0,  0,  0, -2,  0,  0,  0,  0,  0,  0,  0, -1,  0,  0,  0,  0,  0,  0,  0,  0},  
                    {0,  0,  0,  0,  0,  0,  0, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},        
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8, 10,-10,  0,  0,  0,  0,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8, 10,-20,-10,  0,  0,  0,  7,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8, 16, 10,-10,  0,  0,  0,  0,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  2, 10, 10, 10, 10,  0,  0,  0,  0,  0,  0,  0,-20,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2, 10, 10, 10,  3,  0,  0,  5,  0,  0,  0,-20,-20,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2, 10, 10,  5,  0,  0,  5, 10,  0, 45,-40,-40,-20,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0, -3,  0,  0,-10,-10,  0,  2, 10,  5,  0,  0,  1, 10, 15, 35, 45,-40,-40,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0, -3,  0,-13,-10, -6,  0,  0,  5,  0,  0,  1,  3, 15, 25, 35, 45,-40,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0, -3,  0,-18,-16,  0,  0,  0,  0,  0,  0,  2,  3, 15, 25, 35, 25,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0, -3,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  5, 15, 25, 10,  0,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0, -3,  0,  0,  0,  0,  0,  0,  0,  0,  2,  3,  5, 15, 10, 10,  0,  0, 10,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0, -3,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  5,  0, 10, 15,  0, 10, 10,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0, -3, -3,  0,  0,  0,  0,  0,  0,  0,  4,  4,  3,  0,  0, 15, 10, 10, 10,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0, -3, -5, -3,  0,  0,  0,  0,  0,  0,  2,  4,  2,  0,  0,  0, 10, 10, 10,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0, -3, -5, -3,  0,  0,  0,  0,  0,  0,  0,  4,  4,  0,  0,  0,  0, 10,  5,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0, -3, -3, -3,  0,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0, -3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  0,-50,  0,  0,  0,  0,  1, -1,  0,  0,  0,  3,  3,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-20,-50,  0,  0,  0,  0,  1, -1,  0,  0,  1,  5,  8,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  2,  2,  2,  1,-20,-20,-30,  0,  0,  0,  0,  1, -1,  0,  0,  2,  5,  9,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-20,-10,  0,  0,  0,  0,  0,  1, -1,  0,  0,  2,  5,  7,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  4,  4,  2,  3,  2,  1, -5,  0,  0,  0,  0,  0,  0,  1, -1,  0,  0,  2,  4,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1, -1,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  4,  3,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,0.5,  1,  1,  0,  0,  0,  0,  0,  0,-30,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  4,  4,  2,  3,  1,  1,  1,  0,  0,  0,-30,-30,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},          
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,-30,-30,-30,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
					            {0,  0,  0,  0,  0,  5,  4,  2,  2,  1,  1,  1,  0,  0,  0,-30,-30,-25,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},  
					          {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,-25,-22,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,-20,60,-20,  0,  0,  0,  0,  0,  0,  0, 10,  0,-22,-20,  0,  0, -3,  0,  0,  0,  0,  0,  0,  0},
					          {0,  0,  0,  0,  0,  0, 70,60,-20,  0,  0,  0,  0,  0,  0, 10, 10,  0,-19,-18,  0, -6, -3,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0, 65,50,  0,  0,  0,  0,  0,  0,  5, 10,  0,  0,-16,-13, -8, -6,  0,  0,  0,  0,  0,  0,  0},
					          {0,  0,  0,  0,  0,  0,  0,-20,  0,  0,  0,  0,  0,  0,  2,  5,  0,  0,  0,-13,-10, -8,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
					            {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
					            {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
					            {0,  0,  0,  0,  0,  0,  2,  3,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  5,  5,  7,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                      {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
                    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0}};
                    
   lkolumn = 28;         // o 1 mniej, gdy¿ kolumna jest równowa¿na ci¹gowi kwadratów 
   lwierszy = (sizeof(t)/sizeof(float)/(lkolumn+1) + 1)/2-1;                 
   mapa = new float*[lwierszy*2+1];
   for (long i=0;i<lwierszy*2+1;i++) {
     mapa[i] = new float[lkolumn+1];
     for (long j=0;j<lkolumn+1;j++) mapa[i][j] = t[i][j];
   }  	
   
   for (long i=0;i<lwierszy*2+1;i++)
     for (long j=0;j<lkolumn+1;j++)
       mapa[i][j] /= 1.5;
   
   d = new float**[lwierszy];
   for (long i=0;i<lwierszy;i++) {
       d[i] = new float*[lkolumn];
       for (long j=0;j<lkolumn;j++) d[i][j] = new float[4];
   }    
   Norm = new Wektor3**[lwierszy];
   for (long i=0;i<lwierszy;i++) {
       Norm[i] = new Wektor3*[lkolumn];
       for (long j=0;j<lkolumn;j++) Norm[i][j] = new Wektor3[4];
   }    

       
   fprintf(f,"mapa terenu: lwierszy = %d, lkolumn = %d, liczba linii t = %d\n",lwierszy,lkolumn, sizeof(t)/sizeof(float)/(lkolumn+1));
}

Teren::~Teren()
{
  for (long i = 0;i< lwierszy*2+1;i++) delete mapa[i];             
  delete mapa;   
  for (long i=0;i<lwierszy;i++)  {
      for (long j=0;j<lkolumn;j++) delete d[i][j];
      delete d[i];
  }
  delete d;  
  for (long i=0;i<lwierszy;i++)  {
      for (long j=0;j<lkolumn;j++) delete Norm[i][j];
      delete Norm[i];
  }
  delete Norm;  

         
}

float Teren::Wysokosc(float x,float z)      // okreœlanie wysokoœci dla punktu o wsp. (x,z) 
{
  
  float pocz_x = -rozmiar_pola*lkolumn/2,     // wspó³rzêdne lewego górnego krañca terenu
        pocz_z = -rozmiar_pola*lwierszy/2;        
  
  long k = (long)((x - pocz_x)/rozmiar_pola), // wyznaczenie wspó³rzêdnych (w,k) kwadratu
       w = (long)((z - pocz_z)/rozmiar_pola);

  //fprintf(f,"kwadr = (w=%d,k=%d)\n",w,k); 
  //fclose(f);
  //f=fopen("plik.txt","a");

  if ((w < 0)||(w >= lwierszy)||(k < 0)||(k >= lkolumn)) return -1e10;  // jeœli poza map¹
  
  // wyznaczam punkt B - œrodek kwadratu oraz trójk¹t, w którym znajduje siê punkt
  // (rysunek w Teren::PoczatekGrafiki())
  Wektor3 B = Wektor3(pocz_x + (k+0.5)*rozmiar_pola, mapa[w*2+1][k], pocz_z + (w+0.5)*rozmiar_pola); 
  enum tr{ABC=0,ADB=1,BDE=2,CBE=3};       // trójk¹t w którym znajduje siê punkt 
  int trojkat=0; 
  if ((B.x > x)&&(fabs(B.z - z) < fabs(B.x - x))) trojkat = ADB;
  else if ((B.x < x)&&(fabs(B.z - z) < fabs(B.x - x))) trojkat = CBE;
  else if ((B.z > z)&&(fabs(B.z - z) > fabs(B.x - x))) trojkat = ABC;
  else trojkat = BDE;
  
  // wyznaczam normaln¹ do p³aszczyzny a nastêpnie wspó³czynnik d z równania p³aszczyzny
  float dd = d[w][k][trojkat];
  Wektor3 N = Norm[w][k][trojkat];
  float y;
  if (N.y > 0) y = (-dd - N.x*x - N.z*z)/N.y;
  else y = 0;
  
  //fprintf(f,"kwadr = (w=%d,k=%d), trojk = %d,  (x,z)=(%f,%f) y = %f\n",w,k,trojkat,x,z,y);
  //fprintf(f,"kwadr = (w=%d,k=%d), trojk = %d, N=(%f, %f, %f)\n",w,k,trojkat,N.x,N.y,N.z);
  
  return y;    
}

void Teren::PoczatekGrafiki()
{
  // tworze listê wyœwietlania rysuj¹c poszczególne pola mapy za pomoc¹ trójk¹tów 
  // (po 4 trójk¹ty na ka¿de pole):
  enum tr{ABC=0,ADB=1,BDE=2,CBE=3};       
  float pocz_x = -rozmiar_pola*lkolumn/2,     // wspó³rzêdne lewego górnego krañca terenu
        pocz_z = -rozmiar_pola*lwierszy/2;        
  Wektor3 A,B,C,D,E,N;      
  glNewList(PowierzchniaTerenu,GL_COMPILE);
  glBegin(GL_QUADS);
    for (long ix=-1;ix<2;ix++)
      for (long iz=-1;iz<2;iz++)
      if ((ix != 0)||(iz != 0))
      {
        glNormal3f(0,1,0);
        glVertex3f(ix*rozmiar_pola*lkolumn + pocz_x , 0, iz*rozmiar_pola*lwierszy + pocz_z);
        glVertex3f((ix+1)*rozmiar_pola*lkolumn + pocz_x , 0, iz*rozmiar_pola*lwierszy + pocz_z);
        glVertex3f((ix+1)*rozmiar_pola*lkolumn + pocz_x , 0, (iz+1)*rozmiar_pola*lwierszy + pocz_z);
        glVertex3f(ix*rozmiar_pola*lkolumn + pocz_x , 0, (iz+1)*rozmiar_pola*lwierszy + pocz_z);
      }
  glEnd();

  glBegin(GL_TRIANGLES);
    for (long w=0;w<lwierszy;w++) 
      for (long k=0;k<lkolumn;k++) 
      {
          A = Wektor3(pocz_x + k*rozmiar_pola, mapa[w*2][k], pocz_z + w*rozmiar_pola);
          B = Wektor3(pocz_x + (k+0.5)*rozmiar_pola, mapa[w*2+1][k], pocz_z + (w+0.5)*rozmiar_pola);            
          C = Wektor3(pocz_x + (k+1)*rozmiar_pola, mapa[w*2][k+1], pocz_z + w*rozmiar_pola); 
          D = Wektor3(pocz_x + k*rozmiar_pola, mapa[(w+1)*2][k], pocz_z + (w+1)*rozmiar_pola);       
          E = Wektor3(pocz_x + (k+1)*rozmiar_pola, mapa[(w+1)*2][k+1], pocz_z + (w+1)*rozmiar_pola); 
          // tworzê trójk¹t ABC w górnej czêœci kwadratu: 
          //  A o_________o C
          //    |.       .|
          //    |  .   .  | 
          //    |    o B  | 
          //    |  .   .  |
          //    |._______.|
          //  D o         o E
          
          Wektor3 AB = B-A;
          Wektor3 BC = C-B;
          N = (AB*BC).znorm();          
          glNormal3f( N.x, N.y, N.z);
		  glVertex3f( A.x, A.y, A.z);
		  glVertex3f( B.x, B.y, B.z);
          glVertex3f( C.x, C.y, C.z);
          d[w][k][ABC] = -(B^N);          // dodatkowo wyznaczam wyraz wolny z równania plaszyzny trójk¹ta
          Norm[w][k][ABC] = N;          // dodatkowo zapisujê normaln¹ do p³aszczyzny trójk¹ta
          // trójk¹t ADB:
          Wektor3 AD = D-A;
          N = (AD*AB).znorm();          
          glNormal3f( N.x, N.y, N.z);
		  glVertex3f( A.x, A.y, A.z);
		  glVertex3f( D.x, D.y, D.z);
		  glVertex3f( B.x, B.y, B.z);
		  d[w][k][ADB] = -(B^N);       
          Norm[w][k][ADB] = N;
		  // trójk¹t BDE:
          Wektor3 BD = D-B;
          Wektor3 DE = E-D;
          N = (BD*DE).znorm();          
          glNormal3f( N.x, N.y, N.z);
		  glVertex3f( B.x, B.y, B.z);
          glVertex3f( D.x, D.y, D.z);     
          glVertex3f( E.x, E.y, E.z);  
          d[w][k][BDE] = -(B^N);        
          Norm[w][k][BDE] = N;  
          // trójk¹t CBE:
          Wektor3 CB = B-C;
          Wektor3 BE = E-B;
          N = (CB*BE).znorm();          
          glNormal3f( N.x, N.y, N.z);
          glVertex3f( C.x, C.y, C.z);
		  glVertex3f( B.x, B.y, B.z);
          glVertex3f( E.x, E.y, E.z);      
          d[w][k][CBE] = -(B^N);        
          Norm[w][k][CBE] = N;
      }		
  glEnd();
  glEndList(); 
         
   	/*glNewList(PowierzchniaTerenu,GL_COMPILE);
		glBegin(GL_POLYGON);
			glNormal3f( 0.0, 1.0, 0.0);
			glVertex3f( -100, 0, -300.0);
			glVertex3f( -100, 0, 100.0);
			glVertex3f( 100, 0, 100.0);
			glVertex3f( 100, 0, -300.0);
		glEnd();
	glEndList();*/
         
}



void Teren::Rysuj()
{
  glCallList(PowierzchniaTerenu);                 
}

   
